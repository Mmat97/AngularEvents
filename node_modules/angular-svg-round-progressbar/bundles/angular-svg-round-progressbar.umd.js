(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common')) :
    typeof define === 'function' && define.amd ? define('angular-svg-round-progressbar', ['exports', '@angular/core', '@angular/common'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['angular-svg-round-progressbar'] = {}, global.ng.core, global.ng.common));
}(this, (function (exports, i0, i1) { 'use strict';

    var DEGREE_IN_RADIANS = Math.PI / 180;
    var RoundProgressService = /** @class */ (function () {
        function RoundProgressService(document) {
            this.supportsSvg = !!(document &&
                document.createElementNS &&
                document.createElementNS('http://www.w3.org/2000/svg', 'svg').createSVGRect);
            this.base = document && document.head.querySelector('base');
            this.hasPerf =
                typeof window !== 'undefined' &&
                    window.performance &&
                    window.performance.now &&
                    typeof window.performance.now() === 'number';
        }
        /**
         * Resolves a SVG color against the page's `base` tag.
         */
        RoundProgressService.prototype.resolveColor = function (color) {
            if (this.base && this.base.href) {
                var hashIndex = color.indexOf('#');
                if (hashIndex > -1 && color.indexOf('url') > -1) {
                    return color.slice(0, hashIndex) + location.href + color.slice(hashIndex);
                }
            }
            return color;
        };
        /**
         * Generates a timestamp.
         */
        RoundProgressService.prototype.getTimestamp = function () {
            return this.hasPerf ? window.performance.now() : Date.now();
        };
        /**
         * Generates the value for an SVG arc.
         * @param current       Current value.
         * @param total         Maximum value.
         * @param pathRadius    Radius of the SVG path.
         * @param elementRadius Radius of the SVG container.
         * @param isSemicircle  Whether the element should be a semicircle.
         */
        RoundProgressService.prototype.getArc = function (current, total, pathRadius, elementRadius, isSemicircle) {
            if (isSemicircle === void 0) { isSemicircle = false; }
            var value = Math.max(0, Math.min(current || 0, total));
            var maxAngle = isSemicircle ? 180 : 359.9999;
            var percentage = total === 0 ? maxAngle : (value / total) * maxAngle;
            var start = this._polarToCartesian(elementRadius, pathRadius, percentage);
            var end = this._polarToCartesian(elementRadius, pathRadius, 0);
            var arcSweep = percentage <= 180 ? 0 : 1;
            return "M " + start + " A " + pathRadius + " " + pathRadius + " 0 " + arcSweep + " 0 " + end;
        };
        /**
         * Converts polar cooradinates to Cartesian.
         * @param elementRadius  Radius of the wrapper element.
         * @param pathRadius     Radius of the path being described.
         * @param angleInDegrees Degree to be converted.
         */
        RoundProgressService.prototype._polarToCartesian = function (elementRadius, pathRadius, angleInDegrees) {
            var angleInRadians = (angleInDegrees - 90) * DEGREE_IN_RADIANS;
            var x = elementRadius + pathRadius * Math.cos(angleInRadians);
            var y = elementRadius + pathRadius * Math.sin(angleInRadians);
            return x + ' ' + y;
        };
        return RoundProgressService;
    }());
    RoundProgressService.ɵprov = i0.ɵɵdefineInjectable({ factory: function RoundProgressService_Factory() { return new RoundProgressService(i0.ɵɵinject(i1.DOCUMENT, 8)); }, token: RoundProgressService, providedIn: "root" });
    RoundProgressService.decorators = [
        { type: i0.Injectable, args: [{ providedIn: 'root' },] }
    ];
    RoundProgressService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [i1.DOCUMENT,] }] }
    ]; };

    var ROUND_PROGRESS_DEFAULTS = new i0.InjectionToken('ROUND_PROGRESS_DEFAULTS');
    var ɵ0 = {
        radius: 125,
        animation: 'easeOutCubic',
        animationDelay: null,
        duration: 500,
        stroke: 15,
        color: '#45CCCE',
        background: '#EAEAEA',
        responsive: false,
        clockwise: true,
        semicircle: false,
        rounded: false,
    };
    var ROUND_PROGRESS_DEFAULTS_PROVIDER = {
        provide: ROUND_PROGRESS_DEFAULTS,
        useValue: ɵ0,
    };

    /**
     * TERMS OF USE - EASING EQUATIONS
     * Open source under the BSD License.
     *
     * Copyright © 2001 Robert Penner
     * All rights reserved.
     * Redistribution and use in source and binary forms, with or without modification, are permitted
     * provided that the following conditions are met:
     *
     * Redistributions of source code must retain the above copyright notice, this list of conditions
     * and the following disclaimer.
     *
     * Redistributions in binary form must reproduce the above copyright notice, this list of conditions
     * and the following disclaimer in the documentation and/or other materials provided with the
     * distribution.
     *
     * Neither the name of the author nor the names of contributors may be used to endorse or promote
     * products derived from this software without specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
     * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
     * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
     * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
     * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
     * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
     * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     */
    var RoundProgressEase = /** @class */ (function () {
        function RoundProgressEase() {
        }
        // t: current time (or position) of the neonate. This can be seconds or frames, steps,
        // seconds, ms, whatever – as long as the unit is the same as is used for the total time.
        // b: beginning value of the property.
        // c: change between the beginning and destination value of the property.
        // d: total time of the neonate.
        RoundProgressEase.prototype.linearEase = function (t, b, c, d) {
            return (c * t) / d + b;
        };
        RoundProgressEase.prototype.easeInQuad = function (t, b, c, d) {
            return c * (t /= d) * t + b;
        };
        RoundProgressEase.prototype.easeOutQuad = function (t, b, c, d) {
            return -c * (t /= d) * (t - 2) + b;
        };
        RoundProgressEase.prototype.easeInOutQuad = function (t, b, c, d) {
            // tslint:disable-next-line:no-conditional-assignment
            if ((t /= d / 2) < 1) {
                return (c / 2) * t * t + b;
            }
            return (-c / 2) * (--t * (t - 2) - 1) + b;
        };
        RoundProgressEase.prototype.easeInCubic = function (t, b, c, d) {
            return c * (t /= d) * t * t + b;
        };
        RoundProgressEase.prototype.easeOutCubic = function (t, b, c, d) {
            return c * ((t = t / d - 1) * t * t + 1) + b;
        };
        RoundProgressEase.prototype.easeInOutCubic = function (t, b, c, d) {
            // tslint:disable-next-line:no-conditional-assignment
            if ((t /= d / 2) < 1) {
                return (c / 2) * t * t * t + b;
            }
            return (c / 2) * ((t -= 2) * t * t + 2) + b;
        };
        RoundProgressEase.prototype.easeInQuart = function (t, b, c, d) {
            return c * (t /= d) * t * t * t + b;
        };
        RoundProgressEase.prototype.easeOutQuart = function (t, b, c, d) {
            return -c * ((t = t / d - 1) * t * t * t - 1) + b;
        };
        RoundProgressEase.prototype.easeInOutQuart = function (t, b, c, d) {
            // tslint:disable-next-line:no-conditional-assignment
            if ((t /= d / 2) < 1) {
                return (c / 2) * t * t * t * t + b;
            }
            return (-c / 2) * ((t -= 2) * t * t * t - 2) + b;
        };
        RoundProgressEase.prototype.easeInQuint = function (t, b, c, d) {
            return c * (t /= d) * t * t * t * t + b;
        };
        RoundProgressEase.prototype.easeOutQuint = function (t, b, c, d) {
            return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
        };
        RoundProgressEase.prototype.easeInOutQuint = function (t, b, c, d) {
            // tslint:disable-next-line:no-conditional-assignment
            if ((t /= d / 2) < 1) {
                return (c / 2) * t * t * t * t * t + b;
            }
            return (c / 2) * ((t -= 2) * t * t * t * t + 2) + b;
        };
        RoundProgressEase.prototype.easeInSine = function (t, b, c, d) {
            return -c * Math.cos((t / d) * (Math.PI / 2)) + c + b;
        };
        RoundProgressEase.prototype.easeOutSine = function (t, b, c, d) {
            return c * Math.sin((t / d) * (Math.PI / 2)) + b;
        };
        RoundProgressEase.prototype.easeInOutSine = function (t, b, c, d) {
            return (-c / 2) * (Math.cos((Math.PI * t) / d) - 1) + b;
        };
        RoundProgressEase.prototype.easeInExpo = function (t, b, c, d) {
            return t === 0 ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;
        };
        RoundProgressEase.prototype.easeOutExpo = function (t, b, c, d) {
            return t === d ? b + c : c * (-Math.pow(2, (-10 * t) / d) + 1) + b;
        };
        RoundProgressEase.prototype.easeInOutExpo = function (t, b, c, d) {
            if (t === 0) {
                return b;
            }
            if (t === d) {
                return b + c;
            }
            // tslint:disable-next-line:no-conditional-assignment
            if ((t /= d / 2) < 1) {
                return (c / 2) * Math.pow(2, 10 * (t - 1)) + b;
            }
            return (c / 2) * (-Math.pow(2, -10 * --t) + 2) + b;
        };
        RoundProgressEase.prototype.easeInCirc = function (t, b, c, d) {
            return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
        };
        RoundProgressEase.prototype.easeOutCirc = function (t, b, c, d) {
            return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
        };
        RoundProgressEase.prototype.easeInOutCirc = function (t, b, c, d) {
            // tslint:disable-next-line:no-conditional-assignment
            if ((t /= d / 2) < 1) {
                return (-c / 2) * (Math.sqrt(1 - t * t) - 1) + b;
            }
            return (c / 2) * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
        };
        RoundProgressEase.prototype.easeInElastic = function (t, b, c, d) {
            var p = d * 0.3;
            var s = 1.70158;
            var a = c;
            if (t === 0) {
                return b;
            }
            // tslint:disable-next-line:no-conditional-assignment
            if ((t /= d) === 1) {
                return b + c;
            }
            if (a < Math.abs(c)) {
                a = c;
                s = p / 4;
            }
            else {
                s = (p / (2 * Math.PI)) * Math.asin(c / a);
            }
            return -(a * Math.pow(2, 10 * t--) * Math.sin(((t * d - s) * (2 * Math.PI)) / p)) + b;
        };
        RoundProgressEase.prototype.easeOutElastic = function (t, b, c, d) {
            var p = d * 0.3;
            var s = 1.70158;
            var a = c;
            if (t === 0) {
                return b;
            }
            // tslint:disable-next-line:no-conditional-assignment
            if ((t /= d) === 1) {
                return b + c;
            }
            if (a < Math.abs(c)) {
                a = c;
                s = p / 4;
            }
            else {
                s = (p / (2 * Math.PI)) * Math.asin(c / a);
            }
            return a * Math.pow(2, -10 * t) * Math.sin(((t * d - s) * (2 * Math.PI)) / p) + c + b;
        };
        RoundProgressEase.prototype.easeInOutElastic = function (t, b, c, d) {
            var p = d * (0.3 * 1.5);
            var s = 1.70158;
            var a = c;
            if (t === 0) {
                return b;
            }
            // tslint:disable-next-line:no-conditional-assignment
            if ((t /= d / 2) === 2) {
                return b + c;
            }
            if (a < Math.abs(c)) {
                a = c;
                s = p / 4;
            }
            else {
                s = (p / (2 * Math.PI)) * Math.asin(c / a);
            }
            if (t < 1) {
                return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin(((t * d - s) * (2 * Math.PI)) / p)) + b;
            }
            return a * Math.pow(2, -10 * (t -= 1)) * Math.sin(((t * d - s) * (2 * Math.PI)) / p) * 0.5 + c + b;
        };
        RoundProgressEase.prototype.easeInBack = function (t, b, c, d, s) {
            if (s === void 0) { s = 1.70158; }
            return c * (t /= d) * t * ((s + 1) * t - s) + b;
        };
        RoundProgressEase.prototype.easeOutBack = function (t, b, c, d, s) {
            if (s === void 0) { s = 1.70158; }
            return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
        };
        RoundProgressEase.prototype.easeInOutBack = function (t, b, c, d, s) {
            if (s === void 0) { s = 1.70158; }
            // tslint:disable-next-line:no-conditional-assignment
            if ((t /= d / 2) < 1) {
                return (c / 2) * (t * t * (((s *= 1.525) + 1) * t - s)) + b;
            }
            return (c / 2) * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;
        };
        RoundProgressEase.prototype.easeInBounce = function (t, b, c, d) {
            return c - this.easeOutBounce(d - t, 0, c, d) + b;
        };
        RoundProgressEase.prototype.easeOutBounce = function (t, b, c, d) {
            // tslint:disable-next-line:no-conditional-assignment
            if ((t /= d) < 1 / 2.75) {
                return c * (7.5625 * t * t) + b;
            }
            else if (t < 2 / 2.75) {
                return c * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) + b;
            }
            else if (t < 2.5 / 2.75) {
                return c * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) + b;
            }
            return c * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) + b;
        };
        RoundProgressEase.prototype.easeInOutBounce = function (t, b, c, d) {
            if (t < d / 2) {
                return this.easeInBounce(t * 2, 0, c, d) * 0.5 + b;
            }
            return this.easeOutBounce(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
        };
        return RoundProgressEase;
    }());
    RoundProgressEase.ɵprov = i0.ɵɵdefineInjectable({ factory: function RoundProgressEase_Factory() { return new RoundProgressEase(); }, token: RoundProgressEase, providedIn: "root" });
    RoundProgressEase.decorators = [
        { type: i0.Injectable, args: [{ providedIn: 'root' },] }
    ];

    var RoundProgressComponent = /** @class */ (function () {
        function RoundProgressComponent(service, easing, defaults, ngZone) {
            this.service = service;
            this.easing = easing;
            this.defaults = defaults;
            this.ngZone = ngZone;
            /** Radius of the circle. */
            this.radius = this.defaults.radius;
            /** Name of the easing function to use when animating. */
            this.animation = this.defaults.animation;
            /** Time in millisconds by which to delay the animation. */
            this.animationDelay = this.defaults.animationDelay;
            /** Duration of the animation. */
            this.duration = this.defaults.duration;
            /** Width of the circle's stroke. */
            this.stroke = this.defaults.stroke;
            /** Color of the circle. */
            this.color = this.defaults.color;
            /** Background color of the circle. */
            this.background = this.defaults.background;
            /** Whether the circle should take up the width of its parent. */
            this.responsive = this.defaults.responsive;
            /** Whether the circle is filling up clockwise. */
            this.clockwise = this.defaults.clockwise;
            /** Whether to render a semicircle. */
            this.semicircle = this.defaults.semicircle;
            /** Whether the tip of the progress should be rounded off. */
            this.rounded = this.defaults.rounded;
            /** Emits when a new value has been rendered. */
            this.onRender = new i0.EventEmitter();
            this.lastAnimationId = 0;
        }
        /** Animates a change in the current value. */
        RoundProgressComponent.prototype._animateChange = function (from, to) {
            var _this = this;
            if (typeof from !== 'number') {
                from = 0;
            }
            to = this._clamp(to);
            from = this._clamp(from);
            var self = this;
            var changeInValue = to - from;
            var duration = self.duration;
            // Avoid firing change detection for each of the animation frames.
            self.ngZone.runOutsideAngular(function () {
                var start = function () {
                    var startTime = self.service.getTimestamp();
                    var id = ++self.lastAnimationId;
                    requestAnimationFrame(function animation() {
                        var currentTime = Math.min(self.service.getTimestamp() - startTime, duration);
                        var value = self.easing[self.animation](currentTime, from, changeInValue, duration);
                        self._setPath(value);
                        self.onRender.emit(value);
                        if (id === self.lastAnimationId && currentTime < duration) {
                            requestAnimationFrame(animation);
                        }
                    });
                };
                if (_this.animationDelay > 0) {
                    setTimeout(start, _this.animationDelay);
                }
                else {
                    start();
                }
            });
        };
        /** Sets the path dimensions. */
        RoundProgressComponent.prototype._setPath = function (value) {
            if (this.path) {
                var arc = this.service.getArc(value, this.max, this.radius - this.stroke / 2, this.radius, this.semicircle);
                this.path.nativeElement.setAttribute('d', arc);
            }
        };
        /** Clamps a value between the maximum and 0. */
        RoundProgressComponent.prototype._clamp = function (value) {
            return Math.max(0, Math.min(value || 0, this.max));
        };
        /** Determines the SVG transforms for the <path> node. */
        RoundProgressComponent.prototype.getPathTransform = function () {
            var diameter = this._getDiameter();
            if (this.semicircle) {
                return this.clockwise
                    ? "translate(0, " + diameter + ") rotate(-90)"
                    : "translate(" + (diameter + ',' + diameter) + ") rotate(90) scale(-1, 1)";
            }
            else if (!this.clockwise) {
                return "scale(-1, 1) translate(-" + diameter + " 0)";
            }
        };
        /** Resolves a color through the service. */
        RoundProgressComponent.prototype.resolveColor = function (color) {
            return this.service.resolveColor(color);
        };
        /** Change detection callback. */
        RoundProgressComponent.prototype.ngOnChanges = function (changes) {
            if (changes.current) {
                this._animateChange(changes.current.previousValue, changes.current.currentValue);
            }
            else {
                this._setPath(this.current);
            }
        };
        /** Diameter of the circle. */
        RoundProgressComponent.prototype._getDiameter = function () {
            return this.radius * 2;
        };
        /** The CSS height of the wrapper element. */
        RoundProgressComponent.prototype._getElementHeight = function () {
            if (!this.responsive) {
                return (this.semicircle ? this.radius : this._getDiameter()) + 'px';
            }
        };
        /** Viewbox for the SVG element. */
        RoundProgressComponent.prototype._getViewBox = function () {
            var diameter = this._getDiameter();
            return "0 0 " + diameter + " " + (this.semicircle ? this.radius : diameter);
        };
        /** Bottom padding for the wrapper element. */
        RoundProgressComponent.prototype._getPaddingBottom = function () {
            if (this.responsive) {
                return this.semicircle ? '50%' : '100%';
            }
        };
        return RoundProgressComponent;
    }());
    RoundProgressComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'round-progress',
                    changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    template: "<svg xmlns=\"http://www.w3.org/2000/svg\" [attr.viewBox]=\"_getViewBox()\">\n  <circle\n    fill=\"none\"\n    [attr.cx]=\"radius\"\n    [attr.cy]=\"radius\"\n    [attr.r]=\"radius - stroke / 2\"\n    [style.stroke]=\"resolveColor(background)\"\n    [style.stroke-width]=\"stroke\"/>\n\n  <path\n    #path\n    fill=\"none\"\n    [style.stroke-width]=\"stroke\"\n    [style.stroke]=\"resolveColor(color)\"\n    [style.stroke-linecap]=\"rounded ? 'round' : ''\"\n    [attr.transform]=\"getPathTransform()\"/>\n</svg>\n",
                    host: {
                        role: 'progressbar',
                        '[attr.aria-valuemin]': '0',
                        '[attr.aria-valuemax]': 'max',
                        '[attr.aria-valuenow]': 'current',
                        '[style.width]': 'responsive ? "" : _getDiameter() + "px"',
                        '[style.height]': '_getElementHeight()',
                        '[style.padding-bottom]': '_getPaddingBottom()',
                        '[class.responsive]': 'responsive',
                    },
                    styles: [":host{display:block;overflow:hidden;position:relative}:host(.responsive){padding-bottom:100%;width:100%}:host(.responsive)>svg{height:100%;left:0;position:absolute;top:0;width:100%}"]
                },] }
    ];
    RoundProgressComponent.ctorParameters = function () { return [
        { type: RoundProgressService },
        { type: RoundProgressEase },
        { type: undefined, decorators: [{ type: i0.Inject, args: [ROUND_PROGRESS_DEFAULTS,] }] },
        { type: i0.NgZone }
    ]; };
    RoundProgressComponent.propDecorators = {
        path: [{ type: i0.ViewChild, args: ['path',] }],
        current: [{ type: i0.Input }],
        max: [{ type: i0.Input }],
        radius: [{ type: i0.Input }],
        animation: [{ type: i0.Input }],
        animationDelay: [{ type: i0.Input }],
        duration: [{ type: i0.Input }],
        stroke: [{ type: i0.Input }],
        color: [{ type: i0.Input }],
        background: [{ type: i0.Input }],
        responsive: [{ type: i0.Input }],
        clockwise: [{ type: i0.Input }],
        semicircle: [{ type: i0.Input }],
        rounded: [{ type: i0.Input }],
        onRender: [{ type: i0.Output }]
    };

    var RoundProgressModule = /** @class */ (function () {
        function RoundProgressModule() {
        }
        return RoundProgressModule;
    }());
    RoundProgressModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [RoundProgressComponent],
                    exports: [RoundProgressComponent],
                    providers: [ROUND_PROGRESS_DEFAULTS_PROVIDER],
                },] }
    ];

    /**
     * Generated bundle index. Do not edit.
     */

    exports.ROUND_PROGRESS_DEFAULTS = ROUND_PROGRESS_DEFAULTS;
    exports.ROUND_PROGRESS_DEFAULTS_PROVIDER = ROUND_PROGRESS_DEFAULTS_PROVIDER;
    exports.RoundProgressComponent = RoundProgressComponent;
    exports.RoundProgressEase = RoundProgressEase;
    exports.RoundProgressModule = RoundProgressModule;
    exports.RoundProgressService = RoundProgressService;
    exports.RoundprogressModule = RoundProgressModule;
    exports.ɵ0 = ɵ0;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=angular-svg-round-progressbar.umd.js.map
